{"meta":{"title":"小小代码网","subtitle":"代码博客","description":"一个程序员的个人博客","author":"LJJ","url":"https://rookielord.github.io"},"pages":[{"title":"categories","date":"2021-03-28T12:04:01.591Z","updated":"2021-03-28T12:04:01.591Z","comments":true,"path":"categories/index.html","permalink":"https://rookielord.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-28T12:05:29.755Z","updated":"2021-03-28T12:05:29.755Z","comments":true,"path":"tags/index.html","permalink":"https://rookielord.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-03-28T10:57:59.863Z","updated":"2018-08-26T03:36:45.274Z","comments":true,"path":"about/index.html","permalink":"https://rookielord.github.io/about/index.html","excerpt":"","text":"这只是一个关于一个mogeko程序员的小网站。需要了解Mogeko的话请点击，已上转载自萌娘百科。"},{"title":"工具","date":"2021-03-28T04:14:50.140Z","updated":"2021-03-28T04:14:50.140Z","comments":true,"path":"tools/index.html","permalink":"https://rookielord.github.io/tools/index.html","excerpt":"","text":""}],"posts":[{"title":"kotlin如何创建匿名函数","slug":"kotlin","date":"2021-04-06T15:35:20.000Z","updated":"2021-04-06T16:00:52.464Z","comments":true,"path":"2021/04/06/kotlin/","link":"","permalink":"https://rookielord.github.io/2021/04/06/kotlin/","excerpt":"","text":"如何添加匿名类 使用object关键字声明接口，随后重写其的方法。 1）设计接口123interface OnItemClickListener&lt;T&gt; &#123; fun onItemChoose(pos: Int, value: T)&#125; 2）添加接口的方法123fun setListener(onItemClickListener: OnItemClickListener&lt;T&gt;) &#123; listener = onItemClickListener &#125; 3）如何添加123456dialog.setListener(object : OnItemClickListener&lt;String&gt; &#123; override fun onItemChoose(pos: Int, value: String) &#123; dialog.dismiss() Toast.makeText(applicationContext, value, Toast.LENGTH_SHORT).show() &#125; &#125;) 这里的dialog对象为拥有setListener方法的实例。","categories":[{"name":"技巧","slug":"技巧","permalink":"https://rookielord.github.io/categories/技巧/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://rookielord.github.io/tags/Android/"},{"name":"kotlin","slug":"kotlin","permalink":"https://rookielord.github.io/tags/kotlin/"}]},{"title":"使用POI进行Word操作（一）","slug":"word-poi","date":"2021-03-30T15:12:05.000Z","updated":"2021-04-04T08:10:37.162Z","comments":true,"path":"2021/03/30/word-poi/","link":"","permalink":"https://rookielord.github.io/2021/03/30/word-poi/","excerpt":"","text":"操作步骤 步骤一：引用相关POI库 步骤二：创建POI中的word文件对象 步骤三：调用word文件对象的方法对文件进行操作 步骤一：引用相关的POI库 吐槽一下，这一步是最坑的本人尝试了很多版本组合，最新的版本提示class重复引用。老的版本又有存在图片插入后损坏文件。本人把能用的放在后面 加载方式 效果 通过gradle引用3.14poi 使用javatest能够通过，但在编译apk时提示重复类 加载最新的5.1poi包 提示无法找到一些java类 加载3.8的poi包及java包 添加图片时，导致docx文件异常 通过gradle混合加载版本 能够使用 错误引用1-生成app提示类重复1234implementation &apos;org.apache.poi:poi-ooxml:3.14&apos;implementation &apos;org.apache.poi:poi-excelant:3.14&apos;implementation &apos;org.apache.poi:poi-examples:3.14&apos;implementation &apos;org.apache.xmlbeans:xmlbeans:2.6.0&apos; 错误引用2-添加图片时doc错误目前采用直接加载jar包的方式，引用库加载文件如下： 1234567implementation files(&apos;libs/poi-3.8-20120326.jar&apos;)implementation files(&apos;libs/poi-ooxml-3.8-20120326.jar&apos;)implementation files(&apos;libs/poi-ooxml-schemas-3.8-20120326.jar&apos;)implementation files(&apos;libs/xmlbeans-2.3.0.jar&apos;)implementation files(&apos;libs/commons-logging-1.1.jar&apos;)implementation files(&apos;libs/dom4j-1.6.1.jar&apos;)implementation files(&apos;libs/stax-api-1.0.1.jar&apos;) 正确引用-混合版本加载1234implementation group: &apos;org.apache.poi&apos;, name: &apos;poi-ooxml&apos;, version: &apos;3.17&apos;implementation group: &apos;org.apache.xmlbeans&apos;, name: &apos;xmlbeans&apos;, version: &apos;3.1.0&apos;implementation &apos;javax.xml.stream:stax-api:1.0&apos;implementation &apos;com.fasterxml:aalto-xml:1.2.2&apos; 步骤二：创建POI对应的Document对象 首先区别你要加载的word后缀，是.doc还是.docx，因为这两个所创建的对象不一样，如果不对号入座则会报错 org.apache.poi.POIXMLException: org.apache.poi.openxml4j.exceptions.InvalidFormatException: Package should contain a content type part [M1.13] 文件后缀 创建对象 doc HWPFDocument docx XWPFDocument 由于doc是2003年的word版本，此处暂时略过。主要使用docx进行作业 步骤三：文件操作文章类结构 获取主要信息读取字段信息12345678910// 段落，一般只文字内容,图片表格等其他字符，会作为空字符List&lt;XWPFParagraph&gt; paragraphs = doc.getParagraphs();// 表格，整文档中的所有表格List&lt;XWPFTable&gt; tables = doc.getTables();// 图片，获取的都是byte[]List&lt;XWPFPictureData&gt; allPictures = doc.getAllPictures();// 页眉，只能获取不同内容的页眉List&lt;XWPFHeader&gt; headerList = doc.getHeaderList();// 页脚，注意自动生成的编号不会被获取到，只能获取不同类型的页脚List&lt;XWPFFooter&gt; footerList = doc.getFooterList(); 编辑文档内容（覆盖和添加） 注意使用POI的修改操作比较繁琐，建议直接准备一个空文件进行填充 编辑和修改都最好不要对源文件进行修改，而是在修改后通过一个输出流程，将修改后的文件输出 默认所有的操作，最后都有调用 doc.write(out); （一） 文字修改 操作步骤 遍历所有的XWPFParagraph,并查找其中是否有自己需要修改的内容 遍历该XWPFParagraph中的XWPFRun，调用toString()方法查看是否为需要修改的内容 使用run.setText(&quot;修改内容&quot;, 0)方法修改 1234567891011121314151617List&lt;XWPFParagraph&gt; paragraphs = doc.getParagraphs(); for (int i = 0; i &lt; paragraphs.size(); i++) &#123; XWPFParagraph para = paragraphs.get(i); String text = para.getText(); if (!TextUtils.isEmpty(text)) &#123; index = text.indexOf(GOAL); if (index != -1) &#123; List&lt;XWPFRun&gt; runs = para.getRuns(); for (XWPFRun run : runs) &#123; if (run.toString().equals(&quot;GOAL&quot;)) &#123; run.setText(&quot;修改内容&quot;, 0); &#125; &#125; &#125; &#125; &#125; 注意：1. 一定要添加第二个参数0，否则会变成插入操作2. 需要查找的内容不要增加特殊符号，特殊符号会被识别为单独的XWPFRun对象（二） 表格修改&gt;操作步骤&gt;1. 确定需要处理的表格是第几个&gt;2. 根据确定需要编辑的数据在第几行，第几列后，通过XWPFTable-&gt;XWPFTableRow-&gt;CTRow-&gt;XWPFTableCell&gt;3. 在获取到XWPFTableCell后调用123456//表格 List&lt;XWPFTable&gt; tables = doc.getTables(); XWPFTable table = tables.get(0); table.getRow(0).getCell(1).setText(&quot;LJJ&quot;); table.getRow(1).getCell(1).setText(&quot;29&quot;); table.getRow(2).getCell(1).setText(&quot;地球&quot;);注意：1. 若担心异常退出，可以做一些长度限制，通过table.getRows();，然后每一行的row.getCtRow()sizeOfTcArray();判断列数（三） 图片插入此处默认在最后插入图片，插入图片的方式是通过输入流的方式插入1234XWPFRun run = doc.createParagraph().createRun(); FileInputStream picIn = new FileInputStream(new File(picPath)); run.addPicture(picIn, XWPFDocument.PICTURE_TYPE_PNG, &quot;插入图片&quot;, Units.toEMU(256), Units.toEMU(256)); FileUtils.close(picIn);注意： 插入图片打开word出现错误，则需要升级poi版本。目前可以使用的我已经上传在最上面的下载地址了 导入图片打开提示错误 插入图片的宽和高，一定要使用Units.toEMU方法，并传入想要显示的宽和高。直接传入宽和高无法显示 效果图 原始内容 输出内容","categories":[],"tags":[{"name":"poi","slug":"poi","permalink":"https://rookielord.github.io/tags/poi/"},{"name":"word","slug":"word","permalink":"https://rookielord.github.io/tags/word/"}]},{"title":"Dialog控件学习","slug":"dialog","date":"2021-03-28T04:31:27.000Z","updated":"2021-03-28T04:43:31.801Z","comments":true,"path":"2021/03/28/dialog/","link":"","permalink":"https://rookielord.github.io/2021/03/28/dialog/","excerpt":"","text":"Dialog相关学习 1.如何在点击确定或取消按钮时，不取消弹窗 使用场景:在弹窗输入参数后，需要对参数进行校验是否合法时。如果不规范则提示用户重新输入 使用AlertDialog.Builder创建的Dialog，在调用setPositiveButton相关的按钮时，会自动隐藏弹窗。若不想隐藏则需要再获取一次Button设置监听事件 123456789101112131415161718192021222324252627public class CustomDialog extends DialogFragment &#123; private EditText mUserName; private EditText mPassword; @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; LayoutInflater inflater = requireActivity().getLayoutInflater(); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = inflater.inflate(R.layout.custom_dialog, null); mUserName = view.findViewById(R.id.username); mPassword = view.findViewById(R.id.password); builder.setView(view).setPositiveButton(&quot;确定&quot;, null).setNegativeButton(&quot;取消&quot;, null); AlertDialog dialog = builder.create(); // 必须调用show方法，否则下面获取到的button为null dialog.show(); dialog.getButton(AlertDialog.BUTTON_POSITIVE).setOnClickListener(v -&gt; &#123; if (TextUtils.isEmpty(mUserName.getText().toString())) &#123; Toast.makeText(getActivity(), &quot;用户名为空&quot;, Toast.LENGTH_SHORT).show(); return; &#125; else &#123; dialog.dismiss(); &#125; &#125;); return dialog; &#125;&#125; 2.DialogFragment在显示时提示Theme错误1234java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. at androidx.appcompat.app.AppCompatDelegateImpl.createSubDecor(AppCompatDelegateImpl.java:696) at androidx.appcompat.app.AppCompatDelegateImpl.ensureSubDecor(AppCompatDelegateImpl.java:659) at androidx.appcompat.app.AppCompatDelegateImpl.setContentView(AppCompatDelegateImpl.java:552) 该问题属于没有给DialogFragment弹窗依赖的Activity没有使用AppCompat的Theme. 解决方案： 使用的Activity直接继承Activity而不用继承AppCompatActivity 在AndroidManifest对应的Activity的主题改为使用AppCompat的主题 123456&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://rookielord.github.io/categories/移动端/"}],"tags":[{"name":"android","slug":"android","permalink":"https://rookielord.github.io/tags/android/"},{"name":"控件","slug":"控件","permalink":"https://rookielord.github.io/tags/控件/"}]},{"title":"Dart语言整理（一）","slug":"dart1","date":"2020-05-31T10:46:23.000Z","updated":"2020-05-31T12:34:49.601Z","comments":true,"path":"2020/05/31/dart1/","link":"","permalink":"https://rookielord.github.io/2020/05/31/dart1/","excerpt":"","text":"基本语法要点 与java不同，不能直接","categories":[],"tags":[]},{"title":"","slug":"c_language","date":"2020-05-28T16:24:02.939Z","updated":"2020-05-28T16:28:06.483Z","comments":true,"path":"2020/05/29/c_language/","link":"","permalink":"https://rookielord.github.io/2020/05/29/c_language/","excerpt":"","text":"指针 指针就是内存地址 void*代表不关心里面的的内容，只代表一个地址char*代表字符串的指针（常用） 数组就是同一类型的连续存储空间 结构体关键字struct定义过程1234567891011121314// 先定义结构体struct st&#123;int a;int b;&#125;int main(int arg,char[] args)&#123; struct st aa; aa.a = 10; aa.b = 20; printf(&quot;a=%d,b=%d&quot;,aa.a,aa.b);&#125; 枚举关键字 enum 1234567891011enum e_type&#123;red=0,green,blue&#125;int main(int arg,char *args[])&#123;&#125;","categories":[],"tags":[]},{"title":"AS使用Gradle技巧","slug":"gradle-tech","date":"2020-05-02T14:26:06.000Z","updated":"2020-05-02T15:12:43.680Z","comments":true,"path":"2020/05/02/gradle-tech/","link":"","permalink":"https://rookielord.github.io/2020/05/02/gradle-tech/","excerpt":"","text":"新建项目加载下载aar包失败各位朋友们，由于AS是由Google公司基于intelij二次开发的开发工具。众所周知在国内下载国外的一些东西会被X掉。从而很多导致很多人员经常卡住，出现以下情况 以上情况出现后，在网络正常且1min中内仍无变化就100%被X了，导致无法下载。最快的解决方案为在项目最外层的build.gradle的文件的repositories节点中添加阿里云的maven仓库[注意：在allprojects和buildscript都添加] 12345678repositories &#123; maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125; google() jcenter()&#125; 但是这并非最优解，用户可以直接修改新建项目时的gradle配置模板，从而每次新建项目中自动添加阿里云的maven仓库。 步骤如下： 定位到AS的安装目录下的gradle模板，一般为C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects 此处我们只对新建Android项目的gradle配置进行修改，打开C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects\\NewAndroidProject\\root下的build.gradle.ftl文件，将阿里云maven插入。 注意：此处的最好再修改前，建立一个副本文件，以确保在升级AS版本时回复。本人亲测，修改后的build.gradle.ftl会导致升级失败，升级时需要还原默认的模板文件。","categories":[],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://rookielord.github.io/tags/gradle/"},{"name":"开发技巧","slug":"开发技巧","permalink":"https://rookielord.github.io/tags/开发技巧/"}]},{"title":"aidl的使用心得（一）","slug":"aidl1","date":"2019-10-06T10:31:01.000Z","updated":"2019-10-10T14:00:51.588Z","comments":true,"path":"2019/10/06/aidl1/","link":"","permalink":"https://rookielord.github.io/2019/10/06/aidl1/","excerpt":"","text":"什么是AIDL? AIDL是指IPC(Internal progress Communicate)直译为进程间通信，在Android端就是指通俗的指两个APP之间通信。本人认为就是本地引用远程服务，即在客户端（本地）引用服务端（远程）的服务。 AIDL应用场景 就如他的定义一样，一般用于两个APP之间通信，虽然可以用进程间通信可以用全局广播，但由于广播安全性低，且所有APP都能收到。尤其是有序广播，其可以被拦截特性，顾采用AIDL方式进行通信。 一般来说就是支付宝支付，这种就需要使用AIDL方式，确保支持返回成功。 贴图支付宝 AIDL使用为了方便管理分为3个模块 包含内容一、服务端(APP) 定义Service服务，并写好服务中与变量的交互 二、客户端(APP) 引用包含Aidl Module的aar文件 绑定对应服务 三、AIDL Module(Lib) aidl文件夹：包括对应的aidl接口和传输的对象 常量文件，一般包含服务端的服务的action和packageName，确保能够正常引用 用于生成aar文件，方便引用 步骤AIDL Module 创建Aidl的Module包 创建Aidl文件其中包含定义接口和传递的对象 注意： 传递的对象不仅在aidl目录下有，也需要在对应java目录下存在，并且必须实现Parcelable接口 aidl文件中需要自己全部手写，没有自动提示 传递对象的aidl文件需要import对应类所在的位置，以确保能够被找到 buid Module，确保自动生成java对应的接口文件 确定服务端APP的报名和服务的action名，写入常量中 1234567/** * 此处定义服务的相关常量，以确保在客户端时能够具体找到。具体为在aidlserver的Mainifest中写的内容 */public class BaseConstant &#123; public static final String ACTION = \"com.minicoder.peopleservice\"; public static final String PACKAGENAME = \"com.minicoder.aidlserver\";&#125; 服务端(APP) 引用Aidl Moudle implementation project(path: ‘:aidllib’) 定义Service，注意在manifest中设置action名称，定义一个内部类Binder继承Stub,并实现对应aidl中定义的相关方法 1234567891011121314151617181920212223242526272829public class PersonService extends Service &#123; private Common mComm = Common.getInstance(); @Override public IBinder onBind(Intent intent) &#123; return new PersonBinder(); &#125; /** * 此处实现aidl自动生成的Stub类 */ private class PersonBinder extends IChatAidl.Stub &#123; @Override public Person getPerson() throws RemoteException &#123; Person controller = mComm.getController(); return controller; &#125; @Override public int addPerson(Person p) throws RemoteException &#123; List&lt;Person&gt; personList = mComm.getPersons(); boolean success = personList.add(p); return success ? personList.size() - 1 : -1; &#125; &#125;&#125; 123456&lt;service android:name=&quot;.PersonService&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.minicoder.peopleservice&quot;/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 客户端(APP) 引用Aidl Moudle 绑定服务 使用Stub.asInterface(service),将其转化为对应接口 调用接口中的方法注意： 此处获取的对象，不是服务端中的对象，所以在此处更改对象里面的值服务端不会更新，客户端只能将需要修改的值传入然后在服务端的binder中再进行修改 源码下载地址 演示demo","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://rookielord.github.io/tags/android/"},{"name":"aidl","slug":"aidl","permalink":"https://rookielord.github.io/tags/aidl/"}]},{"title":"ConstrantLayout布局相关","slug":"ConstrantLayout","date":"2019-09-28T13:53:15.000Z","updated":"2020-05-04T07:29:18.806Z","comments":true,"path":"2019/09/28/ConstrantLayout/","link":"","permalink":"https://rookielord.github.io/2019/09/28/ConstrantLayout/","excerpt":"","text":"定义一个功能更加强大的RelativeLayout，谷歌官网推荐 功能 约束 MotionLayout 是ConstraintLayout的子类 在单独的xml文件中设置约束条件 直接在两个ConstrainSet之间进行动画过度 过度效果一样 动画定制 作用 可折叠的header 状态反馈 过度效果 幻灯片？ 1.布局高度使用match_parent时，填充整个屏幕若采用以下布局1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn_download&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;下载&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/rv_file_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/btn_download&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; recycleView会占据整个屏幕，而不会受到Button的约束，但是一旦recycleView的高度使用android:layout_height=&quot;wrap_content&quot;则不会出现问题，经过查阅官方文件。 Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”. 即 ConstraintLayout不支持match_parent属性，要使用match_constraint代替，即将设置为0dp就可以实现recycleView在Button下的约束了","categories":[],"tags":[{"name":"布局","slug":"布局","permalink":"https://rookielord.github.io/tags/布局/"}]},{"title":"从零开始使用Cmake进行jni编程教程(三)：jni调用java的方法","slug":"cmake3","date":"2018-09-01T04:43:47.000Z","updated":"2021-03-28T04:30:23.967Z","comments":true,"path":"2018/09/01/cmake3/","link":"","permalink":"https://rookielord.github.io/2018/09/01/cmake3/","excerpt":"","text":"本节内容主要是如何在C++层处理，并在java层返回对应的对象和数据。 应用场景 c++函数中有多个返回 c++函数中有多个参数，java端为了简化操作，直接传入一个包含多个参数的对象 c++端需要直接创建java的类，调用方法 具体逻辑在C++使用的Java的方法： 找到JAVA类(重中之重) 找到需要的属性 找到需要的方法（注意静态方法和实例方法） 操作方法 编写java对象，用于存储多个参数的值和多个返回 在c++通过反射的方式来获取对应参数的值 调用c++中含有多个参数的方法 调用c++方法结果后，将对应的参数返回 这也是为什么一个so对应有一个jar包的原因，用于确保java方面的类的位置路径不会找错 基本类型Java类型 | 签名 ------------ | ------------- boolean | Z short | S float | F byte | B int | I short | S double | D short | S char | C void | V short | S String | java/lang/String 具体实现1)调用Java中的静态方法1.新建名叫LogUtils的类 123456789101112package com.minicoder.coder;import android.util.Log;public class LogUtils &#123; private static final String TAG = &quot;LJJ&quot;; public static void D(String message) &#123; Log.d(TAG, message); &#125;&#125; 接下来需要在对应的native方法的c++找到该类，并调用该方法 1234567// 1.找到类 jclass logclz = env-&gt;FindClass(&quot;com/minicoder/coder/LogUtils&quot;); // 2.找方法 jmethodID mtd_d = env-&gt;GetStaticMethodID(logclz, &quot;D&quot;, &quot;(Ljava/lang/String;)V&quot;); jstring data = env-&gt;NewStringUTF(&quot;从jni中调用的日志&quot;); // 3.调用java层的静态方法 env-&gt;CallStaticVoidMethod(logclz, mtd_d, data); 其中方法的签名和类型，就是上面列表中对应的具体类型，其实我本人是不建议大家去记忆的。我是直接这样处理的 1.将原有方法改为native 2.通过之前的javah方法编译后得到的 找方法时传入的三个值，分别对应1.找到的Jclass对象2.需要调用的方法名3.参数签名，随后就可以在C++层调用JAVA层的静态方法了。 2)调用实例方法与调用静态方法，类似只不过如果该对象没有通过方法传入，则需要在C++里面创建实例 123456789101112131415161718192021222324252627282930/* * Class: com_minicoder_coder_TestUtils * Method: callInatanceMethod * Signature: (Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_com_minicoder_coder_TestUtils_callInatanceMethod (JNIEnv *env, jclass clazz, jstring message) &#123; // 1.找到类 jclass logclz = env-&gt;FindClass(&quot;com/minicoder/coder/LogUtils&quot;); // 2.找构造方法id，用于初始化实例 jmethodID construct = env-&gt;GetMethodID(logclz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jmethodID i = env-&gt;GetMethodID(logclz, &quot;I&quot;, &quot;(Ljava/lang/String;)V&quot;); // 3.实例化对象 jobject testObj = env-&gt;NewObject(logclz, construct, NULL); jstring data = env-&gt;NewStringUTF(&quot;实例方法打印日志&quot;); // 4.调用实例化对象的方法 env-&gt;CallVoidMethod(testObj, i, data); // 5.去掉类引用 // 去掉字符串引用 env-&gt;DeleteLocalRef(data); // 去掉找到的类引用 env-&gt;DeleteLocalRef(logclz); // 去掉实例化对象 env-&gt;DeleteLocalRef(testObj);&#125; 3)调用传入实例的字段和方法在通过javah编译后，其实所有需要的相关信息都获取了。例如此处方法传入的两个Person对象（因为返回值为bool，还需要一个结果对象） 1234567/** * 传入一个人对象，进行修改后再 * @param person 传入的人对象 * @param change 传出改变后的人 * @return 是否改造成功 */public static native boolean changePerson(Person person,Person change); 对应编译出来的c++的.h文件 1234567/* * Class: com_minicoder_coder_TestUtils * Method: changePerson * Signature: (Lcom/minicoder/coder/Person;Lcom/minicoder/coder/Person;)Z */JNIEXPORT jboolean JNICALL Java_com_minicoder_coder_TestUtils_changePerson (JNIEnv *, jclass, jobject, jobject); 随后新建.cpp文件，老规矩三个步骤 获取类 找到字段 获取值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Class: com_minicoder_coder_TestUtils * Method: changePerson * Signature: (Lcom/minicoder/coder/Person;Lcom/minicoder/coder/Person;)Z */JNIEXPORT jboolean JNICALL Java_com_minicoder_coder_TestUtils_changePerson (JNIEnv *env, jclass clazz, jobject person, jobject res) &#123; //1.找到对应的java类 jclass clz = env-&gt;FindClass(&quot;com/minicoder/coder/Person&quot;); //2. 找到对应的字段 jfieldID jname = env-&gt;GetFieldID(clz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); jfieldID jage = env-&gt;GetFieldID(clz, &quot;age&quot;, &quot;I&quot;); jfieldID jgender = env-&gt;GetFieldID(clz, &quot;gender&quot;, &quot;I&quot;); // 3.获取数据 jstring pring = (jstring) env-&gt;GetObjectField(person, jname); int age = env-&gt;GetIntField(person, jage); int gender = env-&gt;GetIntField(person, jgender); // 4.数据改造 // 4.1字符串拼接 jstring nameTemp = env-&gt;NewStringUTF(&quot;红发&quot;); // 4.2 年龄增加 int ageTemp = age + 10; // 4.3 性别改变 int genderTemp = gender + 3; //5.赋值到结果对象 env-&gt;SetIntField(res, jage, ageTemp); env-&gt;SetIntField(res, jgender, genderTemp); env-&gt;SetObjectField(res, jname, nameTemp); // 5.1干掉本地引用 // 去掉类引用 env-&gt;DeleteLocalRef(clz); // 去掉字符串引用 env-&gt;DeleteLocalRef(data); env-&gt;DeleteLocalRef(nameTemp); //6.返回结果值 bool end = false; return end;&#125;","categories":[{"name":"代码","slug":"代码","permalink":"https://rookielord.github.io/categories/代码/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://rookielord.github.io/tags/cmake/"},{"name":"jni","slug":"jni","permalink":"https://rookielord.github.io/tags/jni/"}]},{"title":"从零开始使用Cmake进行jni编程教程(二)：打包so和jar包","slug":"cmake2","date":"2018-07-28T06:23:47.000Z","updated":"2021-03-28T04:30:20.942Z","comments":true,"path":"2018/07/28/cmake2/","link":"","permalink":"https://rookielord.github.io/2018/07/28/cmake2/","excerpt":"","text":"前期准备 确保之前的之前的内容能够正常运行，生成hellow world。如果不行，请点击从零开始使用Cmake进行jni编程教程(一)：搭建环境进行环境配置 确定好jar包的目录结构和so的名称，这两者主要作用有两点。 在生成so时以规定的名称生成 在调用native方法时，可以正确找到正确的类 在编写cpp时可以找到对应java中的类，方便使用对象开始工作 创建新的File-New-New Moudule,创建编译so和jar包的模块 配置新建Moudule的目录进行配置和build.gradle文件进行编辑： 去除多余的引用，并编写makejar命令 将上一个步骤中app下的CMakeLists.txt文件拷贝过来 并按照之前系统配置的jni默认目录的gradle文件，修改当前模块的gradle内容 最后的当前项目的gradle配置文件内容为：`apply plugin: ‘com.android.library’ android { compileSdkVersion 27 defaultConfig { minSdkVersion 17 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; externalNativeBuild { cmake { cppFlags &quot;-std=c++11&quot; //指定编译的so平台，不指定则编译所有的so平台 abiFilters &quot;armeabi&quot;, &quot;x86&quot; } } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } } } dependencies { implementation fileTree(dir: ‘libs’, include: [‘*.jar’])} // 指定jar的原路径和命名def JarName = “coder”def JarTargetPath = “build”def JarSoureFilePath = file(“build/intermediates/packaged-classes/release/classes.jar”) task maekJar(type: Jar) { from zipTree(JarSoureFilePath) baseName = JarName destinationDir = file(JarTargetPath)} ` 编写java的native方法，使用上一篇中设置external tools中的javah命令，生成java类对应的.h文件，复制.h文件重命名后缀为cpp,在header中引用之前的.h文件，并实现具体的内容 cpp文件中就返回博主当前的网站吧 更新CMakeLists.txt中引用的cpp文件，和对应so的名称 更改编译模式，从debug改为release，确保class.jar文件能够在正确的路径下生成 点击build后就可以生成对应的so了 jar包的生成需要点击使用makeJar命令，如果嫌麻烦也可以自己在build\\intermediates\\packaged-classes\\release目录下，拷贝后重命名即可 使用so和jar包 新建项目 把jar包考进lib中，并在gradle中添加引用 在main目录下把新建jniLibs，把需要引用的平台添加进去 运行项目目录结构运行效果","categories":[{"name":"代码","slug":"代码","permalink":"https://rookielord.github.io/categories/代码/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://rookielord.github.io/tags/cmake/"},{"name":"jni","slug":"jni","permalink":"https://rookielord.github.io/tags/jni/"},{"name":"so","slug":"so","permalink":"https://rookielord.github.io/tags/so/"},{"name":"jar包","slug":"jar包","permalink":"https://rookielord.github.io/tags/jar包/"}]},{"title":"从零开始使用Cmake进行jni编程教程(一)：搭建环境","slug":"cmake","date":"2018-07-26T14:06:06.000Z","updated":"2018-08-26T03:15:46.380Z","comments":true,"path":"2018/07/26/cmake/","link":"","permalink":"https://rookielord.github.io/2018/07/26/cmake/","excerpt":"","text":"准备内容 一台能够联网的主机 AS2.2以上的AS（博主使用的是AS3.1) NDK编译包（博主使用的是android-ndk-r14b） 以下为AS和NDK包的下载地址 AS:https://developer.android.google.cn/studio/ NDK:https://developer.android.google.cn/ndk/downloads/ 前期工作 解压下载完成的NDK包，并放在根目录下，位置可以不在C盘，但路径中不允许出现空格或中文字符 打开AS，在configure中选取，Project defauts中选取Project Structure设置NDK路径，这样新建NDK项目后就不用每次重新设置。 若无法设置，则可以到新建AS安装目录下直接设置NDK路径在C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects\\NewAndroidProject\\root\\local.properties.ftl中添加末尾一行指定NDK编译路径ndk.dir=C\\:\\android-ndk-r14b 设置快速jni编译命令点击File-Setting-Tool在External中按照以下方式编译javah,命令，确保能够通过该命令快速生成java对应的.h文件（注意：此处JDK的路径需要设置为java的jdk路径，使用AS自带的路径很可能无法编译） .h文件快速生成命令 NDK 生成so命令（该命令可以不用） NDK清空命令（该命令可以不用） 测试NDK是否可以编译 新建一个Android Project jni项目，然后把这三个 选中C++版本11或14，这里我选择了11，下面两个可以不勾选，一般jni编译不会用到 编译完成如果没有安装Cmake包则会提示用户自己去下载，安装完成后，即可开始jni的编程 Activity界面 public class MainActivity extends AppCompatActivity { // 使用该静态代码块指定加载的jni即so包 static { System.loadLibrary(&quot;native-lib&quot;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(stringFromJNI()); } // jni调用的方法，该方法需要有对应的cpp文件 public native String stringFromJNI(); } cpp文件 #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_com_minicoder_cmakedmo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); } CMakeLists.txt(该文件自动生成，注意其中的几个变量设置) 只要可以在确定APP可以正常运行则则表示搭建jni编译环境成功","categories":[{"name":"代码","slug":"代码","permalink":"https://rookielord.github.io/categories/代码/"}],"tags":[{"name":"cmake","slug":"cmake","permalink":"https://rookielord.github.io/tags/cmake/"},{"name":"jni","slug":"jni","permalink":"https://rookielord.github.io/tags/jni/"}]},{"title":"使用注解机制代替枚举","slug":"intDef","date":"2018-07-22T06:51:41.000Z","updated":"2018-08-26T03:16:45.306Z","comments":true,"path":"2018/07/22/intDef/","link":"","permalink":"https://rookielord.github.io/2018/07/22/intDef/","excerpt":"","text":"使用注解等注解代替Enum在Android开发过程中，使用Enum所占用的内存比单纯使用int变量定义的内容明显要大，为了提高软件的使用性，建议使用注解的方法。 #使用方法 1.引用依赖包目前以Android Studio 3.1.2为例子 `implementation &apos;com.android.support:support-annotations:27.1.1&apos;` 如果是以前的版本则使用 `compiler &apos;com.android.support:support-annotations:27.1.1&apos;` 2.创建注解类如果是以Int作为标志，则使用IntDef的注解，以下以季节为例子 @IntDef({SPRING, SUMMER, AUTUMN, WINTER}) @Retention(RetentionPolicy.SOURCE) public @interface Season { int SPRING = 0; int SUMMER = 1; int AUTUMN = 2; int WINTER = 3; } 步骤 创建interface 在interface中添加字段 在interface前面添加@ 添加IntDef({添加之前添加的字段}) 在IntDef后添加@Retention(RetentionPolicy.SOURCE) 3.具体引用@Season int season = Season.SPRING; switch (season) { case Season.AUTUMN: break; case Season.SPRING: break; case Season.SUMMER: break; case Season.WINTER: break; } 4.备注 如果在使用的变量的前方标注了注解，则可以在switch(season)后通过alt+enter直接列举出所有的case情况。","categories":[{"name":"技巧","slug":"技巧","permalink":"https://rookielord.github.io/categories/技巧/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://rookielord.github.io/tags/注解/"},{"name":"IntDef","slug":"IntDef","permalink":"https://rookielord.github.io/tags/IntDef/"},{"name":"Enum","slug":"Enum","permalink":"https://rookielord.github.io/tags/Enum/"}]},{"title":"Win10下MarkdownPad2无法预览问题修复","slug":"markdownpad2win10","date":"2018-07-01T15:02:51.000Z","updated":"2018-08-26T03:17:22.488Z","comments":true,"path":"2018/07/01/markdownpad2win10/","link":"","permalink":"https://rookielord.github.io/2018/07/01/markdownpad2win10/","excerpt":"","text":"在win10环境下使用MarkdownPad2编译md文件，在预览界面会莫名其妙崩溃。 解决办法如下： 1.点击【yes】跳转到官方界面一看，果然有相关的提示内容 2.下载其中的Awesomium 1.6.6 SDK安装完成后 3.重启MarkdownPad2完美解决问题。 这里为了方便直接给大家提供需要下载的两个文件的地址，一般来说下载完第一个后就可以解决问题了。 Awesomium 1.6.6 SDK Microsoft’s DirectX End-User Runtimes (June 2010)","categories":[{"name":"软件配置","slug":"软件配置","permalink":"https://rookielord.github.io/categories/软件配置/"}],"tags":[{"name":"MarkdownPad2","slug":"MarkdownPad2","permalink":"https://rookielord.github.io/tags/MarkdownPad2/"},{"name":"win10","slug":"win10","permalink":"https://rookielord.github.io/tags/win10/"}]}]}