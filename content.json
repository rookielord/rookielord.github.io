{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于我","text":"这只是一个关于一个mogeko程序员的小网站。需要了解Mogeko的话请点击，已上转载自萌娘百科。","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ConstrantLayout布局相关","text":"定义一个功能更加强大的RelativeLayout，谷歌官网推荐 功能 约束 MotionLayout 是ConstraintLayout的子类 在单独的xml文件中设置约束条件 直接在两个ConstrainSet之间进行动画过度 过度效果一样 动画定制 作用 可折叠的header 状态反馈 过度效果 幻灯片？ 1.布局高度使用match_parent时，填充整个屏幕若采用以下布局1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn_download&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;下载&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/rv_file_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/btn_download&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; recycleView会占据整个屏幕，而不会受到Button的约束，但是一旦recycleView的高度使用android:layout_height=&quot;wrap_content&quot;则不会出现问题，经过查阅官方文件。 Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”. 即 ConstraintLayout不支持match_parent属性，要使用match_constraint代替，即将设置为0dp就可以实现recycleView在Button下的约束了","link":"/2019/09/28/ConstrantLayout/"},{"title":"","text":"指针 指针就是内存地址 void*代表不关心里面的的内容，只代表一个地址char*代表字符串的指针（常用） 数组就是同一类型的连续存储空间 结构体关键字struct定义过程1234567891011121314// 先定义结构体struct st{int a;int b;}int main(int arg,char[] args){ struct st aa; aa.a = 10; aa.b = 20; printf(&quot;a=%d,b=%d&quot;,aa.a,aa.b);} 枚举关键字 enum 1234567891011enum e_type{red=0,green,blue}int main(int arg,char *args[]){}","link":"/2020/05/29/c_language/"},{"title":"aidl的使用心得（一）","text":"什么是AIDL? AIDL是指IPC(Internal progress Communicate)直译为进程间通信，在Android端就是指通俗的指两个APP之间通信。本人认为就是本地引用远程服务，即在客户端（本地）引用服务端（远程）的服务。 AIDL应用场景 就如他的定义一样，一般用于两个APP之间通信，虽然可以用进程间通信可以用全局广播，但由于广播安全性低，且所有APP都能收到。尤其是有序广播，其可以被拦截特性，顾采用AIDL方式进行通信。 一般来说就是支付宝支付，这种就需要使用AIDL方式，确保支持返回成功。 贴图支付宝 AIDL使用为了方便管理分为3个模块 包含内容一、服务端(APP) 定义Service服务，并写好服务中与变量的交互 二、客户端(APP) 引用包含Aidl Module的aar文件 绑定对应服务 三、AIDL Module(Lib) aidl文件夹：包括对应的aidl接口和传输的对象 常量文件，一般包含服务端的服务的action和packageName，确保能够正常引用 用于生成aar文件，方便引用 步骤AIDL Module 创建Aidl的Module包 创建Aidl文件其中包含定义接口和传递的对象 注意： 传递的对象不仅在aidl目录下有，也需要在对应java目录下存在，并且必须实现Parcelable接口 aidl文件中需要自己全部手写，没有自动提示 传递对象的aidl文件需要import对应类所在的位置，以确保能够被找到 buid Module，确保自动生成java对应的接口文件 确定服务端APP的报名和服务的action名，写入常量中 1234567/** * 此处定义服务的相关常量，以确保在客户端时能够具体找到。具体为在aidlserver的Mainifest中写的内容 */public class BaseConstant { public static final String ACTION = \"com.minicoder.peopleservice\"; public static final String PACKAGENAME = \"com.minicoder.aidlserver\";} 服务端(APP) 引用Aidl Moudle implementation project(path: ‘:aidllib’) 定义Service，注意在manifest中设置action名称，定义一个内部类Binder继承Stub,并实现对应aidl中定义的相关方法 1234567891011121314151617181920212223242526272829public class PersonService extends Service { private Common mComm = Common.getInstance(); @Override public IBinder onBind(Intent intent) { return new PersonBinder(); } /** * 此处实现aidl自动生成的Stub类 */ private class PersonBinder extends IChatAidl.Stub { @Override public Person getPerson() throws RemoteException { Person controller = mComm.getController(); return controller; } @Override public int addPerson(Person p) throws RemoteException { List&lt;Person&gt; personList = mComm.getPersons(); boolean success = personList.add(p); return success ? personList.size() - 1 : -1; } }} 123456&lt;service android:name=&quot;.PersonService&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.minicoder.peopleservice&quot;/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 客户端(APP) 引用Aidl Moudle 绑定服务 使用Stub.asInterface(service),将其转化为对应接口 调用接口中的方法注意： 此处获取的对象，不是服务端中的对象，所以在此处更改对象里面的值服务端不会更新，客户端只能将需要修改的值传入然后在服务端的binder中再进行修改 源码下载地址 演示demo","link":"/2019/10/06/aidl1/"},{"title":"从零开始使用Cmake进行jni编程教程(一)：搭建环境","text":"准备内容 一台能够联网的主机 AS2.2以上的AS（博主使用的是AS3.1) NDK编译包（博主使用的是android-ndk-r14b） 以下为AS和NDK包的下载地址 AS:https://developer.android.google.cn/studio/ NDK:https://developer.android.google.cn/ndk/downloads/ 前期工作 解压下载完成的NDK包，并放在根目录下，位置可以不在C盘，但路径中不允许出现空格或中文字符 打开AS，在configure中选取，Project defauts中选取Project Structure设置NDK路径，这样新建NDK项目后就不用每次重新设置。 若无法设置，则可以到新建AS安装目录下直接设置NDK路径在C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects\\NewAndroidProject\\root\\local.properties.ftl中添加末尾一行指定NDK编译路径ndk.dir=C\\:\\android-ndk-r14b 设置快速jni编译命令点击File-Setting-Tool在External中按照以下方式编译javah,命令，确保能够通过该命令快速生成java对应的.h文件（注意：此处JDK的路径需要设置为java的jdk路径，使用AS自带的路径很可能无法编译） .h文件快速生成命令 NDK 生成so命令（该命令可以不用） NDK清空命令（该命令可以不用） 测试NDK是否可以编译 新建一个Android Project jni项目，然后把这三个 选中C++版本11或14，这里我选择了11，下面两个可以不勾选，一般jni编译不会用到 编译完成如果没有安装Cmake包则会提示用户自己去下载，安装完成后，即可开始jni的编程 Activity界面 public class MainActivity extends AppCompatActivity { // 使用该静态代码块指定加载的jni即so包 static { System.loadLibrary(&quot;native-lib&quot;); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(stringFromJNI()); } // jni调用的方法，该方法需要有对应的cpp文件 public native String stringFromJNI(); } cpp文件 #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_com_minicoder_cmakedmo_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); } CMakeLists.txt(该文件自动生成，注意其中的几个变量设置) 只要可以在确定APP可以正常运行则则表示搭建jni编译环境成功","link":"/2018/07/26/cmake/"},{"title":"从零开始使用Cmake进行jni编程教程(三)：jni调用java的方法","text":"本节内容主要是如何在C++层处理，并在java层返回对应的对象和数据。 应用场景 c++函数中有多个返回 c++函数中有多个参数，java端为了简化操作，直接传入一个包含多个参数的对象 c++端需要直接创建java的类，调用方法 具体逻辑在C++使用的Java的方法： 找到JAVA类(重中之重) 找到需要的属性 找到需要的方法（注意静态方法和实例方法） 操作方法 编写java对象，用于存储多个参数的值和多个返回 在c++通过反射的方式来获取对应参数的值 调用c++中含有多个参数的方法 调用c++方法结果后，将对应的参数返回 这也是为什么一个so对应有一个jar包的原因，用于确保java方面的类的位置路径不会找错 基本类型Java类型 | 签名 ------------ | ------------- boolean | Z short | S float | F byte | B int | I short | S double | D short | S char | C void | V short | S String | java/lang/String 具体实现1)调用Java中的静态方法1.新建名叫LogUtils的类 123456789101112package com.minicoder.coder;import android.util.Log;public class LogUtils { private static final String TAG = &quot;LJJ&quot;; public static void D(String message) { Log.d(TAG, message); }} 接下来需要在对应的native方法的c++找到该类，并调用该方法 1234567// 1.找到类 jclass logclz = env-&gt;FindClass(&quot;com/minicoder/coder/LogUtils&quot;); // 2.找方法 jmethodID mtd_d = env-&gt;GetStaticMethodID(logclz, &quot;D&quot;, &quot;(Ljava/lang/String;)V&quot;); jstring data = env-&gt;NewStringUTF(&quot;从jni中调用的日志&quot;); // 3.调用java层的静态方法 env-&gt;CallStaticVoidMethod(logclz, mtd_d, data); 其中方法的签名和类型，就是上面列表中对应的具体类型，其实我本人是不建议大家去记忆的。我是直接这样处理的 1.将原有方法改为native 2.通过之前的javah方法编译后得到的 找方法时传入的三个值，分别对应1.找到的Jclass对象2.需要调用的方法名3.参数签名，随后就可以在C++层调用JAVA层的静态方法了。 2)调用实例方法与调用静态方法，类似只不过如果该对象没有通过方法传入，则需要在C++里面创建实例 123456789101112131415161718192021222324252627282930/* * Class: com_minicoder_coder_TestUtils * Method: callInatanceMethod * Signature: (Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_com_minicoder_coder_TestUtils_callInatanceMethod (JNIEnv *env, jclass clazz, jstring message) { // 1.找到类 jclass logclz = env-&gt;FindClass(&quot;com/minicoder/coder/LogUtils&quot;); // 2.找构造方法id，用于初始化实例 jmethodID construct = env-&gt;GetMethodID(logclz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jmethodID i = env-&gt;GetMethodID(logclz, &quot;I&quot;, &quot;(Ljava/lang/String;)V&quot;); // 3.实例化对象 jobject testObj = env-&gt;NewObject(logclz, construct, NULL); jstring data = env-&gt;NewStringUTF(&quot;实例方法打印日志&quot;); // 4.调用实例化对象的方法 env-&gt;CallVoidMethod(testObj, i, data); // 5.去掉类引用 // 去掉字符串引用 env-&gt;DeleteLocalRef(data); // 去掉找到的类引用 env-&gt;DeleteLocalRef(logclz); // 去掉实例化对象 env-&gt;DeleteLocalRef(testObj);} 3)调用传入实例的字段和方法在通过javah编译后，其实所有需要的相关信息都获取了。例如此处方法传入的两个Person对象（因为返回值为bool，还需要一个结果对象） 1234567/** * 传入一个人对象，进行修改后再 * @param person 传入的人对象 * @param change 传出改变后的人 * @return 是否改造成功 */public static native boolean changePerson(Person person,Person change); 对应编译出来的c++的.h文件 1234567/* * Class: com_minicoder_coder_TestUtils * Method: changePerson * Signature: (Lcom/minicoder/coder/Person;Lcom/minicoder/coder/Person;)Z */JNIEXPORT jboolean JNICALL Java_com_minicoder_coder_TestUtils_changePerson (JNIEnv *, jclass, jobject, jobject); 随后新建.cpp文件，老规矩三个步骤 获取类 找到字段 获取值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Class: com_minicoder_coder_TestUtils * Method: changePerson * Signature: (Lcom/minicoder/coder/Person;Lcom/minicoder/coder/Person;)Z */JNIEXPORT jboolean JNICALL Java_com_minicoder_coder_TestUtils_changePerson (JNIEnv *env, jclass clazz, jobject person, jobject res) { //1.找到对应的java类 jclass clz = env-&gt;FindClass(&quot;com/minicoder/coder/Person&quot;); //2. 找到对应的字段 jfieldID jname = env-&gt;GetFieldID(clz, &quot;name&quot;, &quot;Ljava/lang/String;&quot;); jfieldID jage = env-&gt;GetFieldID(clz, &quot;age&quot;, &quot;I&quot;); jfieldID jgender = env-&gt;GetFieldID(clz, &quot;gender&quot;, &quot;I&quot;); // 3.获取数据 jstring pring = (jstring) env-&gt;GetObjectField(person, jname); int age = env-&gt;GetIntField(person, jage); int gender = env-&gt;GetIntField(person, jgender); // 4.数据改造 // 4.1字符串拼接 jstring nameTemp = env-&gt;NewStringUTF(&quot;红发&quot;); // 4.2 年龄增加 int ageTemp = age + 10; // 4.3 性别改变 int genderTemp = gender + 3; //5.赋值到结果对象 env-&gt;SetIntField(res, jage, ageTemp); env-&gt;SetIntField(res, jgender, genderTemp); env-&gt;SetObjectField(res, jname, nameTemp); // 5.1干掉本地引用 // 去掉类引用 env-&gt;DeleteLocalRef(clz); // 去掉字符串引用 env-&gt;DeleteLocalRef(data); env-&gt;DeleteLocalRef(nameTemp); //6.返回结果值 bool end = false; return end;}","link":"/2018/09/01/cmake3/"},{"title":"AS使用Gradle技巧","text":"新建项目加载下载aar包失败各位朋友们，由于AS是由Google公司基于intelij二次开发的开发工具。众所周知在国内下载国外的一些东西会被X掉。从而很多导致很多人员经常卡住，出现以下情况 以上情况出现后，在网络正常且1min中内仍无变化就100%被X了，导致无法下载。最快的解决方案为在项目最外层的build.gradle的文件的repositories节点中添加阿里云的maven仓库[注意：在allprojects和buildscript都添加] 12345678repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } google() jcenter()} 但是这并非最优解，用户可以直接修改新建项目时的gradle配置模板，从而每次新建项目中自动添加阿里云的maven仓库。 步骤如下： 定位到AS的安装目录下的gradle模板，一般为C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects 此处我们只对新建Android项目的gradle配置进行修改，打开C:\\Program Files\\Android\\Android Studio\\plugins\\android\\lib\\templates\\gradle-projects\\NewAndroidProject\\root下的build.gradle.ftl文件，将阿里云maven插入。 注意：此处的最好再修改前，建立一个副本文件，以确保在升级AS版本时回复。本人亲测，修改后的build.gradle.ftl会导致升级失败，升级时需要还原默认的模板文件。","link":"/2020/05/02/gradle-tech/"},{"title":"从零开始使用Cmake进行jni编程教程(二)：打包so和jar包","text":"前期准备 确保之前的之前的内容能够正常运行，生成hellow world。如果不行，请点击从零开始使用Cmake进行jni编程教程(一)：搭建环境进行环境配置 确定好jar包的目录结构和so的名称，这两者主要作用有两点。 在生成so时以规定的名称生成 在调用native方法时，可以正确找到正确的类 在编写cpp时可以找到对应java中的类，方便使用对象开始工作 创建新的File-New-New Moudule,创建编译so和jar包的模块 配置新建Moudule的目录进行配置和build.gradle文件进行编辑： 去除多余的引用，并编写makejar命令 将上一个步骤中app下的CMakeLists.txt文件拷贝过来 并按照之前系统配置的jni默认目录的gradle文件，修改当前模块的gradle内容 最后的当前项目的gradle配置文件内容为：`apply plugin: ‘com.android.library’ android { compileSdkVersion 27 defaultConfig { minSdkVersion 17 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; externalNativeBuild { cmake { cppFlags &quot;-std=c++11&quot; //指定编译的so平台，不指定则编译所有的so平台 abiFilters &quot;armeabi&quot;, &quot;x86&quot; } } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } } } dependencies { implementation fileTree(dir: ‘libs’, include: [‘*.jar’])} // 指定jar的原路径和命名def JarName = “coder”def JarTargetPath = “build”def JarSoureFilePath = file(“build/intermediates/packaged-classes/release/classes.jar”) task maekJar(type: Jar) { from zipTree(JarSoureFilePath) baseName = JarName destinationDir = file(JarTargetPath)} ` 编写java的native方法，使用上一篇中设置external tools中的javah命令，生成java类对应的.h文件，复制.h文件重命名后缀为cpp,在header中引用之前的.h文件，并实现具体的内容 cpp文件中就返回博主当前的网站吧 更新CMakeLists.txt中引用的cpp文件，和对应so的名称 更改编译模式，从debug改为release，确保class.jar文件能够在正确的路径下生成 点击build后就可以生成对应的so了 jar包的生成需要点击使用makeJar命令，如果嫌麻烦也可以自己在build\\intermediates\\packaged-classes\\release目录下，拷贝后重命名即可 使用so和jar包 新建项目 把jar包考进lib中，并在gradle中添加引用 在main目录下把新建jniLibs，把需要引用的平台添加进去 运行项目目录结构运行效果","link":"/2018/07/28/cmake2/"},{"title":"Dart语言整理（一）","text":"基本语法要点 与java不同，不能直接","link":"/2020/05/31/dart1/"},{"title":"使用注解机制代替枚举","text":"使用注解等注解代替Enum在Android开发过程中，使用Enum所占用的内存比单纯使用int变量定义的内容明显要大，为了提高软件的使用性，建议使用注解的方法。 #使用方法 1.引用依赖包目前以Android Studio 3.1.2为例子 `implementation &apos;com.android.support:support-annotations:27.1.1&apos;` 如果是以前的版本则使用 `compiler &apos;com.android.support:support-annotations:27.1.1&apos;` 2.创建注解类如果是以Int作为标志，则使用IntDef的注解，以下以季节为例子 @IntDef({SPRING, SUMMER, AUTUMN, WINTER}) @Retention(RetentionPolicy.SOURCE) public @interface Season { int SPRING = 0; int SUMMER = 1; int AUTUMN = 2; int WINTER = 3; } 步骤 创建interface 在interface中添加字段 在interface前面添加@ 添加IntDef({添加之前添加的字段}) 在IntDef后添加@Retention(RetentionPolicy.SOURCE) 3.具体引用@Season int season = Season.SPRING; switch (season) { case Season.AUTUMN: break; case Season.SPRING: break; case Season.SUMMER: break; case Season.WINTER: break; } 4.备注 如果在使用的变量的前方标注了注解，则可以在switch(season)后通过alt+enter直接列举出所有的case情况。","link":"/2018/07/22/intDef/"},{"title":"Win10下MarkdownPad2无法预览问题修复","text":"在win10环境下使用MarkdownPad2编译md文件，在预览界面会莫名其妙崩溃。 解决办法如下： 1.点击【yes】跳转到官方界面一看，果然有相关的提示内容 2.下载其中的Awesomium 1.6.6 SDK安装完成后 3.重启MarkdownPad2完美解决问题。 这里为了方便直接给大家提供需要下载的两个文件的地址，一般来说下载完第一个后就可以解决问题了。 Awesomium 1.6.6 SDK Microsoft’s DirectX End-User Runtimes (June 2010)","link":"/2018/07/01/markdownpad2win10/"}],"tags":[{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"aidl","slug":"aidl","link":"/tags/aidl/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"jni","slug":"jni","link":"/tags/jni/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"开发技巧","slug":"开发技巧","link":"/tags/开发技巧/"},{"name":"so","slug":"so","link":"/tags/so/"},{"name":"jar包","slug":"jar包","link":"/tags/jar包/"},{"name":"注解","slug":"注解","link":"/tags/注解/"},{"name":"IntDef","slug":"IntDef","link":"/tags/IntDef/"},{"name":"Enum","slug":"Enum","link":"/tags/Enum/"},{"name":"MarkdownPad2","slug":"MarkdownPad2","link":"/tags/MarkdownPad2/"},{"name":"win10","slug":"win10","link":"/tags/win10/"}],"categories":[{"name":"代码","slug":"代码","link":"/categories/代码/"},{"name":"技巧","slug":"技巧","link":"/categories/技巧/"},{"name":"软件配置","slug":"软件配置","link":"/categories/软件配置/"}]}